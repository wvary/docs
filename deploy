#!/usr/bin/env node

var fs = require('fs');
var execSync = require('child_process').execSync;
var _ = require('lodash');
var semverCompare = require('semver-compare');
var yargs = require('yargs');

var argv = yargs
  .usage('Usage: $0 <command> [options]')
  .example('$0 build --hash --docs-version', 'Builds the mkdocs project using the hash and docs-version.')
  .example('$0 build --tag --docs-version', 'Builds the mkdocs project using the tag.')
  .example('$0 delete --docs-version', 'Removes a version from gh-pages.')
  .example('$0 link --docs-version --orig-version', 'Creates symbolic link in the "v" folder and add a new version to the versions.json file.')
  // .demand(1)
  .command('build', 'Builds and deploys one or more version.')
  .command('delete', 'Removes a version.')
  .command('link', 'Links one version to another by creating a symbolic link in the "v" folder.')
  .option('docs-version', {
    describe: 'The version to tag the build as.'
  })
  .option('hash', {
    default: '',
    describe: 'The hash to checkout.  docs-version is required if hash is specified.'
  })
  .option('tag', {
    default: '',
    describe: 'The tag to checkout.  docs-version is not necessary if tag is provided.'
  })
  .option('init', {
    describe: 'Set to true if you want to build specified version into an empty content.  If false, new version is added to existing gh-pages branch contents.',
    type: 'boolean',
    default: 'false'
  })
  .count('v')
  .alias('v', 'verbose')
  .help('h')
  .alias('h', 'help')
  .argv;

var tempDir = process.env.TMPDIR + 'docs_' + Date.now();
var customDir = tempDir + '/custom';
var wwwDir = tempDir + '/www';
var versionDir = wwwDir + '/v/' + argv.docsVersion;
var latestVersion;

function log() {
  if (argv.v) {
    console.log('>>> ' + arguments[0], arguments[1]);
  }
}

/*
 * Create temp directory where builds are copied to
 */
function createTempDirectory() {
  var statement = 'mkdir -p ' + wwwDir;
  log('creating temp directories, statement:', statement);
  execSync(statement);
}

/*
 * Copy custom files to temp folder so we can use to inject into tag/branch/hash
 * where files in this custom folder may not exist
 */
function copyCustomFolderToTempDir() {
  var statement = 'cp -r docs/custom ' + tempDir;
  log('copying custom folder, statement:', statement);
  execSync('mkdir -p ' + customDir);
  execSync(statement);
}

/*
 * Copy existing contents from gh-pages branch to temp directory
 */
function copyGhPagesContentsToTempDir() {
  var statement;

  if (!argv.init) {
    // we want to create new build into existing gh-page contents

    // checkout gh-pages
    var statement = 'git checkout gh-pages';
    log('checkout gh-pages, statement:', statement);
    execSync(statement);

    // copy files to temp folder
    statement = 'cp -r * ' + wwwDir;
    log('copying contents to temp dir, statement:', statement);
    execSync(statement);

    checkoutPrevBranch();
  }

  // create "v" directory if not exist
  statement = 'mkdir -p ' + wwwDir + '/v';
  log('create "v" directory, statement:', statement);
  execSync(statement);
}

/*
 * Checkout hash or tag to be built
 */
function checkoutHashOrTag() {
  var statement = 'git checkout ' + argv.tag || argv.hash;
  log('run git checkout, statement:', statement);
  execSync(statement);
}

/*
 * Copy custom folder from temp directory to the branch we 
 * are building
 */
function injectCustomFolder() {
  var statement = 'cp -r ' + customDir + ' docs/custom';
  log('injecting custom folder, statement:', statement);
  execSync(statement);
}

/*
 * Inject custom-loader.js into the mkdocs.yml file in the
 * branch we are building
 */
function injectCustomLoaderJs() {
  // set file name
  var file = 'mkdocs.yml';
  log('adding custom-loader.js to mkdocs file:', file);

  // read file mkdocs.yml
  var mkdocsContent = fs.readFileSync(file, 'utf-8');

  // inject custom/custom-loader.js if necessary
  var ary = mkdocsContent.split('extra_javascript: ');
  if (ary.length === 1) {
    // there's no extra_javascript in the file, append it
    log('mkdodcs.yml does not have an "extra_javascript" line');
    mkdocsContent += '\nextra_javascript: [\'custom/custom-loader.js\']';
  } else {
    // mkdocs contains the extra_javascript property, see if we need to insert custom-loader.js
    log('found "extra_javascript" line in mkdocs.yml');
    var subary = ary[1].split('\n');
    var extraJavascript = JSON.parse(subary[0].replace(/\'/g, '"'));
    if (extraJavascript.indexOf('custom/custom-loader.js') === -1) {
      log('adding custom/custom-loader.js to extra_javascript');
      extraJavascript.push('custom/custom-loader.js');
      subary[0] = JSON.stringify(extraJavascript);
    }
    ary[1] = subary.join('\n');
    mkdocsContent = ary.join('extra_javascript: ');
  }

  fs.writeFileSync(file, mkdocsContent);
}

/*
 * Run the mkdocs build command
 */
function runMkdocsBuildCommand() {
  log('Executing mkdocs build, statement:', 'mkdocs build');
  execSync('mkdocs build');
}

/*
 * Remove version folder from "v" directory inside the temp directory
 */
function removeVersionFolder() {
  var statement = 'rm -rf ' + versionDir;
  log('Removing existing version folder, statement:', statement);
  execSync(statement);
}

/*
 * Move site folder to "v" directory inside temp dirctory
 */
function moveSiteFolderToTempDirectory() {
  var statement = 'mv site ' + versionDir;
  log('Moving site folder to "v" diretory, statement:', statement);
  execSync(statement);
}

/*
 * Update versions.json in temp directory
 * mode can be 'add' or 'delete'
 * If mode is 'add', then we are adding a version to the file.
 * If mode is 'delete', then we are remove a version from the file.
 * We also sort the file to be descending order using the version property.
 */
function updateVersionsJson(mode) {
  var file = wwwDir + '/versions.json';
  log('Updating version file:', file);


  var content;

  if (fs.existsSync(file)) {
    // file exists, read it
    content = fs.readFileSync(file, 'utf-8');
  } else {
    // file does not exist, set to empty array
    content = '[]';
  }

  var json = JSON.parse(content);
  var idx = _.findIndex(json, function(row) {
    return (row.version === argv.docsVersion);
  });
  log('idx is', idx);
  if (mode === 'add' && idx === -1) {
    // version not in array, and we want to add it
    var row = {
      aliases: [],
      version: argv.docsVersion,
      title: argv.docsVersion      
    };
    log('adding version row:', row);
    json.push(row);
  } else if (mode === 'delete' && idx > -1) {
    // version is in array and we want to remove it
    log('removing row', idx);
    json.splice(idx, 1);
  }

  // sort list for descending order
  json.sort(function(rowA, rowB) {
    return -semverCompare(rowA.version, rowB.version);
  });

  if (json.length) {
    // save latest version for later use
    latestVersion = json[0].version;
  }
  log('latestVersion is ' + latestVersion);

  log('json', json);
  log('saving versions json to ' + file);
  fs.writeFileSync(file, JSON.stringify(json));
}

/*
 * Copy latest version content to the root directory of temp directory
 */
function copyLatestVersionToRoot() {
  if (latestVersion) {
    var statement = 'cp -r ' + wwwDir + '/v/' + latestVersion + '/* ' + wwwDir;
    log('copying latest version to root, statement:', statement);
    execSync(statement);
  }
}

/*
 * Copy contents from temp directory to gh-pages branch
 */
function copyContentsToGhPages() {
  // checkout branch
  var statement = 'git checkout gh-pages';
  log('checkout gh-pages, statement:', statement);
  execSync(statement);

  // remove all files
  statement = 'rm -r *';
  log('remove all files in branch, statement:', statement);
  execSync(statement);

  // copy files from temp directory to branch
  statement = 'cp -r ' + wwwDir + '/* .';
  log('copying files from temp directory, statement:', statement);
  execSync(statement);

  // commit to branch
  statement = 'git add . ; git commit -m "saving build v' + argv.docsVersion + '" ;';
  log('commit files to branch, statement:', statement);
  execSync(statement);
}

/*
 * Clean changed and untracked files in current branch
 */
function cleanGitBranch() {
  var statement = 'git checkout . ; git clean -f -d';
  log('clean branch, statement:', statement);
  execSync(statement);
}

/*
 * Checkout previous branch
 */
function checkoutPrevBranch() {
  var statement = 'git checkout -';
  log('checkout previous branch, statement:', statement);
  execSync(statement);
}

/*
 * Create symbolic link from new version to orig version
 */
function createSymbolicLink() {
  var statement = 'ln -sf ' + wwwDir + '/v/' + argv.origVersion + ' ' + wwwDir + '/v/' + argv.docsVersion;
  log('creating symbolic link, statement:', statement);
  execSync(statement);
}

/*
 * Build a version
 */
function build() {
  createTempDirectory();
  copyCustomFolderToTempDir();
  copyGhPagesContentsToTempDir();
  checkoutHashOrTag()
  injectCustomFolder();
  injectCustomLoaderJs();
  runMkdocsBuildCommand();
  removeVersionFolder();
  moveSiteFolderToTempDirectory();
  updateVersionsJson('add');
  cleanGitBranch();
  checkoutPrevBranch();
  copyLatestVersionToRoot();
  copyContentsToGhPages();
  checkoutPrevBranch();
}

/*
 * remove a version

 */
function delele() {
  createTempDirectory();
  copyGhPagesContentsToTempDir();
  removeVersionFolder();
  updateVersionsJson('delete');
  copyLatestVersionToRoot();
  copyContentsToGhPages();
  checkoutPrevBranch();
}

/*
 * creates a symbolic link from one version to another
 */
function link() {
  createTempDirectory();
  copyGhPagesContentsToTempDir();
  createSymbolicLink();
  updateVersionsJson('add');
  copyContentsToGhPages();
  checkoutPrevBranch();
}

log('command:', argv._[0]);
log('tag:', argv.tag);
log('hash:', argv.hash);
log('docs-version:', argv.docsVersion);
log('tempDir:', tempDir);
log('customDir:', customDir);
log('wwwDir:', wwwDir);
log('versionDir:', versionDir);

switch(argv._[0]) {
  case 'build':
    build();
    break;
  case 'delete':
    delele();
    break;
  case 'link':
    link();
    break;
}
